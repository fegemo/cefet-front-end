{"version":3,"sources":["node_modules/browser-pack/_prelude.js","scripts/classes/caniuse.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"caniuse.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*jshint curly: true, eqeqeq: true, immed: true, indent: 4, browser: true, jquery: true, evil: true, regexdash: true, browser: true, trailing: true, sub: true, unused: true, devel: true */\n\n// author: andi smith\n// website: www.andismith.com\n// version: 0.1\n\nvar canIUse = (function () {\n\n    /*  CONFIGURATION =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */\n\n    //  URL to the data feed\n    var SOURCE_DATA_URL = 'https://raw.github.com/Fyrd/caniuse/master/data.json';\n\n    /*  Turn auto run on page load on or off with AUTO_RUN.\n        If you turn it off, just use canIUse.render() to kick it off again.\n        If you don't want the WhenCanIUse data to load in the background, turn BE_READY to false.\n    */\n    var AUTO_RUN = true,\n        BE_READY = true;\n\n    /*  Configure the browsers you want to show here.\n        The order defines the order they will appear on the page.\n\n        Browser options are:\n        * android   - Android\n        * and_ff    - Android Firefox\n        * and_chr   - Android Chrome\n        * bb        - Blackberry\n        * chrome    - Google Chrome\n        * firefox   - Mozilla Firefox\n        * ie        - Internet Explorer\n        * ios_saf   - iOS Safari\n        * opera     - Opera\n        * op_mini   - Opera Mini\n        * op_mob    - Opera Mobile\n        * safari    - Apple Safari\n    */\n    var BROWSERS = ['chrome', 'firefox', 'ie', 'opera', 'safari'];\n\n    //  Customise HTML here\n    var TMPL_TITLE = '<h2>{title}</h2>', // feature title {title}\n        TMPL_STATUS = '<p class=\"status\">{status}</p>', // feature status (W3C Recommendation) {status}\n        TMPL_DESCRIPTION = '<p>Suportado a partir de:</p>', // description to user\n        TMPL_DESKTOP_TITLE = '', // desktop header\n        TMPL_MOBILE_TITLE = '', // mobile header\n        TMPL_SUPPORT_WRAPPER = '<ul class=\"agents\">{items}</ul>', // support wrapper {items}\n        TMPL_SUPPORT = '<li title=\"{browser} - {support}\" class=\"icon-{browsercode} {supportcode}\"><span class=\"version\">{version}{prefixed}</span></li>',\n        TMPL_PREFIX_NOTE = '<p>* requer prefixo.</p>',\n        TMPL_LEGEND = '<ul class=\"legend\"><li>Legenda:</li><li class=\"y\">Sim</li><li class=\"n\">Não</li><li class=\"a\">Parcial</li><li class=\"p\">Polyfill</li></ul>',\n        TMPL_FOOTER = '<p class=\"stats\">Dados de <a href=\"http://caniuse.com/#feat={feature}\" target=\"_blank\">caniuse.com</a></p>',\n        TMPL_LOADING = '<h2>Carregando</h2>',\n        TMPL_ERROR = '<h2>Erro</h2><p>Feature \"{feature}\" não encontrada!</p>';\n\n    /* END CONFIGURATION =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */\n\n    var canIUseData, // store data for multiple uses.\n        storeElementId, // temp storage for elementId if we need to JSONP request\n        populateOnLoad; // temp storage for if we should populate\n\n\n\n    // get feature data based on feature name\n    function getFeature(featureName) {\n        featureName = featureName.toLowerCase();\n        if (canIUseData.query) {\n            return canIUseData.query.results.json.data[featureName];\n        } else if (canIUseData.data) {\n            return canIUseData.data[featureName];\n        } else {\n            return null;\n        }\n    }\n\n    // get the full text description for the support status\n    function getSupportStatus(key) {\n        var status = {\n            \"y\": \"Yes\",\n            \"x\": \"With Prefix\",\n            \"n\": \"No\",\n            \"a\": \"Partial Support\",\n            \"p\": \"Polyfill\",\n            \"u\": \"Unknown\"\n        };\n\n        return status[key];\n    }\n\n    // get the specification status\n    function getSpecStatus(key) {\n        var status = {\n            \"rec\": \"W3C Recommendation\",\n            \"pr\": \"W3C Proposed Recommendation\",\n            \"cr\": \"W3C Candidate Recommendation\",\n            \"wd\": \"W3C Working Draft\",\n            \"other\": \"Non-W3C, but Reputable\",\n            \"unoff\": \"Unofficial or W3C 'Note'\"\n        };\n\n        return status[key] || \"Unknown\";\n    }\n\n    // find the first version that had this status\n    function find(needle, haystack) {\n\n        var result = {\n                \"version\": -1,\n                \"prefixed\": false\n            },\n            compare = -1;\n\n        for (var item in haystack) {\n            if (haystack.hasOwnProperty(item) && haystack[item].indexOf(needle) > -1) {\n                // some browser versions are formatted n-n, take the first number for comparison\n                compare = parseFloat(item.split('-')[0]);\n                // is this version lower than the current version we have stored?\n                if (result.version === -1 || result.version > compare) {\n                    result.version = compare;\n                    result.prefixed = (haystack[item].indexOf('x') > -1);\n                }\n            }\n        }\n        return result;\n    }\n\n    function findSupport(browserData) {\n        var status = ['y', 'a', 'p'],\n            result = {};\n        // find what support is available for this browser\n        for (var i = 0; i < status.length; i++) {\n            result = find(status[i], browserData);\n            if (result.version !== -1) {\n                return {\n                    'result': status[i], // what type of support\n                    'prefixed': result.prefixed,\n                    'version': (result.version !== '0') ? result.version : '0' // the version with that support\n                };\n            }\n        }\n        return {\n            'result': 'n',\n            'prefixed': false,\n            'version': 'No'\n        };\n    }\n\n    /* put the data in a more platable format */\n    function generateResults(feature) {\n        var agents = {},\n            results = {},\n            currentBrowser = '',\n            support = {};\n\n        agents = canIUseData.agents || canIUseData.query.results.json.agents;\n\n        results.title = feature.title; // feature name\n        results.code = feature; // feature code?\n        results.status = getSpecStatus(feature.status); // feature specification status\n        results.agents = [];\n\n        for (var i = 0, l = BROWSERS.length; i < l; i++) {\n\n            currentBrowser = BROWSERS[i];\n\n            if (agents[currentBrowser]) {\n\n                support = findSupport(feature.stats[BROWSERS[i]]);\n\n                results.agents.push({\n                    \"browsercode\": currentBrowser,\n                    \"prefixed\": support.prefixed,\n                    \"supportcode\": support.result,\n                    \"support\": getSupportStatus(support.result),\n                    \"title\": agents[currentBrowser].browser,\n                    \"type\": agents[currentBrowser].type.toLowerCase(),\n                    \"version\": support.version\n                });\n            }\n        }\n\n        return results;\n    }\n\n\n    function generateHtml(results) {\n\n        var html = '',\n            resultHtml = '',\n            desktopHtml = '',\n            mobileHtml = '',\n            prefixes = false,\n            result = {},\n            i = 0,\n            l = 0;\n\n        resultHtml = TMPL_TITLE.replace('{title}', results.title);\n        resultHtml += TMPL_STATUS.replace('{status}', results.status);\n        resultHtml += TMPL_DESCRIPTION;\n\n        for (i = 0, l = results.agents.length; i < l; i++) {\n            result = results.agents[i]; // simply things\n\n            // we need to show that prefix notice, captain\n            if (result.prefixed) {\n                prefixes = true;\n            }\n\n            html = TMPL_SUPPORT.replace(/\\{browsercode\\}/g, result.browsercode)\n                                    .replace(/\\{prefixed\\}/g, (result.prefixed === true) ? '*' : '')\n                                    .replace(/\\{supportcode\\}/g, result.supportcode)\n                                    .replace(/\\{support\\}/g, result.support)\n                                    .replace(/\\{browser\\}/g, result.title)\n                                    .replace(/\\{version\\}/g, result.version);\n\n            if (result.type === 'desktop') {\n                desktopHtml += html;\n            } else if (result.type === 'mobile') {\n                mobileHtml += html;\n            }\n        }\n\n        // only show if we are including desktop browsers\n        if (desktopHtml !== '') {\n            resultHtml += TMPL_DESKTOP_TITLE;\n            resultHtml += TMPL_SUPPORT_WRAPPER.replace(/\\{items\\}/g, desktopHtml);\n        }\n\n        // only show if we are including mobile browsers\n        if (mobileHtml !== '') {\n            resultHtml += TMPL_MOBILE_TITLE;\n            resultHtml += TMPL_SUPPORT_WRAPPER.replace(/\\{items\\}/g, mobileHtml);\n        }\n\n        if (prefixes) {\n            resultHtml += TMPL_PREFIX_NOTE;\n        }\n\n        resultHtml += TMPL_LEGEND;\n        resultHtml += TMPL_FOOTER.replace(/\\{feature\\}/g, results.featureCode);\n        return resultHtml;\n    }\n\n    function generate(elementId) {\n        var $canIUse = [],\n            $instance,\n            featureCode = '',\n            feature = {},\n            result = {},\n            i = 0,\n            l = 0;\n\n        if (typeof elementId === \"undefined\") {\n            $canIUse = document.querySelectorAll('.caniuse');\n        } else {\n            $canIUse.push(document.getElementById(elementId));\n        }\n\n        l = $canIUse.length;\n\n        for (i = 0; i < l; i++) {\n            $instance = $canIUse[i];\n            featureCode = $instance.getAttribute('data-feature') || 'unknown';\n            feature = getFeature(featureCode);\n            if (feature) {\n                result = generateResults(feature);\n                result.featureCode = featureCode;\n                $instance.innerHTML = generateHtml(result);\n            } else {\n                $instance.innerHTML = TMPL_ERROR.replace(/\\{feature\\}/g, featureCode);\n            }\n        }\n    }\n\n    function showLoading(elementId) {\n        var $canIUse = [],\n            $instance,\n            i = 0,\n            l = 0;\n\n        if (typeof elementId === \"undefined\") {\n            $canIUse = document.querySelectorAll('.caniuse');\n        } else {\n            $canIUse.push(document.getElementById(elementId));\n        }\n\n        l = $canIUse.length;\n\n        for (i = 0; i < l; i++) {\n            $instance = $canIUse[i];\n            $instance.innerHTML = TMPL_LOADING;\n        }\n    }\n\n    /*\n     * Load the data that will be used to display information.\n     */\n    function loadData(elementId, populate) {\n        var url = '',\n            script = document.createElement('SCRIPT');\n\n        url = 'http://query.yahooapis.com/v1/public/yql?q=' +\n            'select * from json where url = \\'' + SOURCE_DATA_URL + '\\'' +\n            '&format=json&jsonCompat=new&callback=canIUseDataLoaded';\n\n        // remember these for when our JSONP returns\n        storeElementId = elementId;\n        populateOnLoad = populate;\n\n        script.src = url;\n        document.body.appendChild(script);\n    }\n\n    function populate(elementId) {\n        if (typeof canIUseData === 'undefined') {\n            showLoading(elementId);\n            loadData(elementId, true);\n        } else {\n            generate(elementId);\n        }\n    }\n\n    /*\n     * Public Methods\n     */\n    return {\n        render: populate,\n        dataLoaded: function (data) {\n            canIUseData = data;\n            if (populateOnLoad) {\n                generate(storeElementId);\n            }\n        },\n        init: (function () {\n            if (AUTO_RUN) {\n                populate();\n            } else if (BE_READY) {\n                loadData(undefined, false);\n            }\n        })()\n    };\n}());\n\nwindow.canIUseDataLoaded = function canIUseDataLoaded(data) {\n    canIUse.dataLoaded(data);\n};\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzY3JpcHRzL2NsYXNzZXMvY2FuaXVzZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKmpzaGludCBjdXJseTogdHJ1ZSwgZXFlcWVxOiB0cnVlLCBpbW1lZDogdHJ1ZSwgaW5kZW50OiA0LCBicm93c2VyOiB0cnVlLCBqcXVlcnk6IHRydWUsIGV2aWw6IHRydWUsIHJlZ2V4ZGFzaDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSwgdHJhaWxpbmc6IHRydWUsIHN1YjogdHJ1ZSwgdW51c2VkOiB0cnVlLCBkZXZlbDogdHJ1ZSAqL1xuXG4vLyBhdXRob3I6IGFuZGkgc21pdGhcbi8vIHdlYnNpdGU6IHd3dy5hbmRpc21pdGguY29tXG4vLyB2ZXJzaW9uOiAwLjFcblxudmFyIGNhbklVc2UgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgLyogIENPTkZJR1VSQVRJT04gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS0gKi9cblxuICAgIC8vICBVUkwgdG8gdGhlIGRhdGEgZmVlZFxuICAgIHZhciBTT1VSQ0VfREFUQV9VUkwgPSAnaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9GeXJkL2Nhbml1c2UvbWFzdGVyL2RhdGEuanNvbic7XG5cbiAgICAvKiAgVHVybiBhdXRvIHJ1biBvbiBwYWdlIGxvYWQgb24gb3Igb2ZmIHdpdGggQVVUT19SVU4uXG4gICAgICAgIElmIHlvdSB0dXJuIGl0IG9mZiwganVzdCB1c2UgY2FuSVVzZS5yZW5kZXIoKSB0byBraWNrIGl0IG9mZiBhZ2Fpbi5cbiAgICAgICAgSWYgeW91IGRvbid0IHdhbnQgdGhlIFdoZW5DYW5JVXNlIGRhdGEgdG8gbG9hZCBpbiB0aGUgYmFja2dyb3VuZCwgdHVybiBCRV9SRUFEWSB0byBmYWxzZS5cbiAgICAqL1xuICAgIHZhciBBVVRPX1JVTiA9IHRydWUsXG4gICAgICAgIEJFX1JFQURZID0gdHJ1ZTtcblxuICAgIC8qICBDb25maWd1cmUgdGhlIGJyb3dzZXJzIHlvdSB3YW50IHRvIHNob3cgaGVyZS5cbiAgICAgICAgVGhlIG9yZGVyIGRlZmluZXMgdGhlIG9yZGVyIHRoZXkgd2lsbCBhcHBlYXIgb24gdGhlIHBhZ2UuXG5cbiAgICAgICAgQnJvd3NlciBvcHRpb25zIGFyZTpcbiAgICAgICAgKiBhbmRyb2lkICAgLSBBbmRyb2lkXG4gICAgICAgICogYW5kX2ZmICAgIC0gQW5kcm9pZCBGaXJlZm94XG4gICAgICAgICogYW5kX2NociAgIC0gQW5kcm9pZCBDaHJvbWVcbiAgICAgICAgKiBiYiAgICAgICAgLSBCbGFja2JlcnJ5XG4gICAgICAgICogY2hyb21lICAgIC0gR29vZ2xlIENocm9tZVxuICAgICAgICAqIGZpcmVmb3ggICAtIE1vemlsbGEgRmlyZWZveFxuICAgICAgICAqIGllICAgICAgICAtIEludGVybmV0IEV4cGxvcmVyXG4gICAgICAgICogaW9zX3NhZiAgIC0gaU9TIFNhZmFyaVxuICAgICAgICAqIG9wZXJhICAgICAtIE9wZXJhXG4gICAgICAgICogb3BfbWluaSAgIC0gT3BlcmEgTWluaVxuICAgICAgICAqIG9wX21vYiAgICAtIE9wZXJhIE1vYmlsZVxuICAgICAgICAqIHNhZmFyaSAgICAtIEFwcGxlIFNhZmFyaVxuICAgICovXG4gICAgdmFyIEJST1dTRVJTID0gWydjaHJvbWUnLCAnZmlyZWZveCcsICdpZScsICdvcGVyYScsICdzYWZhcmknXTtcblxuICAgIC8vICBDdXN0b21pc2UgSFRNTCBoZXJlXG4gICAgdmFyIFRNUExfVElUTEUgPSAnPGgyPnt0aXRsZX08L2gyPicsIC8vIGZlYXR1cmUgdGl0bGUge3RpdGxlfVxuICAgICAgICBUTVBMX1NUQVRVUyA9ICc8cCBjbGFzcz1cInN0YXR1c1wiPntzdGF0dXN9PC9wPicsIC8vIGZlYXR1cmUgc3RhdHVzIChXM0MgUmVjb21tZW5kYXRpb24pIHtzdGF0dXN9XG4gICAgICAgIFRNUExfREVTQ1JJUFRJT04gPSAnPHA+U3Vwb3J0YWRvIGEgcGFydGlyIGRlOjwvcD4nLCAvLyBkZXNjcmlwdGlvbiB0byB1c2VyXG4gICAgICAgIFRNUExfREVTS1RPUF9USVRMRSA9ICcnLCAvLyBkZXNrdG9wIGhlYWRlclxuICAgICAgICBUTVBMX01PQklMRV9USVRMRSA9ICcnLCAvLyBtb2JpbGUgaGVhZGVyXG4gICAgICAgIFRNUExfU1VQUE9SVF9XUkFQUEVSID0gJzx1bCBjbGFzcz1cImFnZW50c1wiPntpdGVtc308L3VsPicsIC8vIHN1cHBvcnQgd3JhcHBlciB7aXRlbXN9XG4gICAgICAgIFRNUExfU1VQUE9SVCA9ICc8bGkgdGl0bGU9XCJ7YnJvd3Nlcn0gLSB7c3VwcG9ydH1cIiBjbGFzcz1cImljb24te2Jyb3dzZXJjb2RlfSB7c3VwcG9ydGNvZGV9XCI+PHNwYW4gY2xhc3M9XCJ2ZXJzaW9uXCI+e3ZlcnNpb259e3ByZWZpeGVkfTwvc3Bhbj48L2xpPicsXG4gICAgICAgIFRNUExfUFJFRklYX05PVEUgPSAnPHA+KiByZXF1ZXIgcHJlZml4by48L3A+JyxcbiAgICAgICAgVE1QTF9MRUdFTkQgPSAnPHVsIGNsYXNzPVwibGVnZW5kXCI+PGxpPkxlZ2VuZGE6PC9saT48bGkgY2xhc3M9XCJ5XCI+U2ltPC9saT48bGkgY2xhc3M9XCJuXCI+TsOjbzwvbGk+PGxpIGNsYXNzPVwiYVwiPlBhcmNpYWw8L2xpPjxsaSBjbGFzcz1cInBcIj5Qb2x5ZmlsbDwvbGk+PC91bD4nLFxuICAgICAgICBUTVBMX0ZPT1RFUiA9ICc8cCBjbGFzcz1cInN0YXRzXCI+RGFkb3MgZGUgPGEgaHJlZj1cImh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD17ZmVhdHVyZX1cIiB0YXJnZXQ9XCJfYmxhbmtcIj5jYW5pdXNlLmNvbTwvYT48L3A+JyxcbiAgICAgICAgVE1QTF9MT0FESU5HID0gJzxoMj5DYXJyZWdhbmRvPC9oMj4nLFxuICAgICAgICBUTVBMX0VSUk9SID0gJzxoMj5FcnJvPC9oMj48cD5GZWF0dXJlIFwie2ZlYXR1cmV9XCIgbsOjbyBlbmNvbnRyYWRhITwvcD4nO1xuXG4gICAgLyogRU5EIENPTkZJR1VSQVRJT04gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LSAqL1xuXG4gICAgdmFyIGNhbklVc2VEYXRhLCAvLyBzdG9yZSBkYXRhIGZvciBtdWx0aXBsZSB1c2VzLlxuICAgICAgICBzdG9yZUVsZW1lbnRJZCwgLy8gdGVtcCBzdG9yYWdlIGZvciBlbGVtZW50SWQgaWYgd2UgbmVlZCB0byBKU09OUCByZXF1ZXN0XG4gICAgICAgIHBvcHVsYXRlT25Mb2FkOyAvLyB0ZW1wIHN0b3JhZ2UgZm9yIGlmIHdlIHNob3VsZCBwb3B1bGF0ZVxuXG5cblxuICAgIC8vIGdldCBmZWF0dXJlIGRhdGEgYmFzZWQgb24gZmVhdHVyZSBuYW1lXG4gICAgZnVuY3Rpb24gZ2V0RmVhdHVyZShmZWF0dXJlTmFtZSkge1xuICAgICAgICBmZWF0dXJlTmFtZSA9IGZlYXR1cmVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChjYW5JVXNlRGF0YS5xdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbklVc2VEYXRhLnF1ZXJ5LnJlc3VsdHMuanNvbi5kYXRhW2ZlYXR1cmVOYW1lXTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW5JVXNlRGF0YS5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FuSVVzZURhdGEuZGF0YVtmZWF0dXJlTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldCB0aGUgZnVsbCB0ZXh0IGRlc2NyaXB0aW9uIGZvciB0aGUgc3VwcG9ydCBzdGF0dXNcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0U3RhdHVzKGtleSkge1xuICAgICAgICB2YXIgc3RhdHVzID0ge1xuICAgICAgICAgICAgXCJ5XCI6IFwiWWVzXCIsXG4gICAgICAgICAgICBcInhcIjogXCJXaXRoIFByZWZpeFwiLFxuICAgICAgICAgICAgXCJuXCI6IFwiTm9cIixcbiAgICAgICAgICAgIFwiYVwiOiBcIlBhcnRpYWwgU3VwcG9ydFwiLFxuICAgICAgICAgICAgXCJwXCI6IFwiUG9seWZpbGxcIixcbiAgICAgICAgICAgIFwidVwiOiBcIlVua25vd25cIlxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdGF0dXNba2V5XTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHNwZWNpZmljYXRpb24gc3RhdHVzXG4gICAgZnVuY3Rpb24gZ2V0U3BlY1N0YXR1cyhrZXkpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHtcbiAgICAgICAgICAgIFwicmVjXCI6IFwiVzNDIFJlY29tbWVuZGF0aW9uXCIsXG4gICAgICAgICAgICBcInByXCI6IFwiVzNDIFByb3Bvc2VkIFJlY29tbWVuZGF0aW9uXCIsXG4gICAgICAgICAgICBcImNyXCI6IFwiVzNDIENhbmRpZGF0ZSBSZWNvbW1lbmRhdGlvblwiLFxuICAgICAgICAgICAgXCJ3ZFwiOiBcIlczQyBXb3JraW5nIERyYWZ0XCIsXG4gICAgICAgICAgICBcIm90aGVyXCI6IFwiTm9uLVczQywgYnV0IFJlcHV0YWJsZVwiLFxuICAgICAgICAgICAgXCJ1bm9mZlwiOiBcIlVub2ZmaWNpYWwgb3IgVzNDICdOb3RlJ1wiXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0YXR1c1trZXldIHx8IFwiVW5rbm93blwiO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IHZlcnNpb24gdGhhdCBoYWQgdGhpcyBzdGF0dXNcbiAgICBmdW5jdGlvbiBmaW5kKG5lZWRsZSwgaGF5c3RhY2spIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIFwidmVyc2lvblwiOiAtMSxcbiAgICAgICAgICAgICAgICBcInByZWZpeGVkXCI6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGFyZSA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGl0ZW0gaW4gaGF5c3RhY2spIHtcbiAgICAgICAgICAgIGlmIChoYXlzdGFjay5oYXNPd25Qcm9wZXJ0eShpdGVtKSAmJiBoYXlzdGFja1tpdGVtXS5pbmRleE9mKG5lZWRsZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyBhcmUgZm9ybWF0dGVkIG4tbiwgdGFrZSB0aGUgZmlyc3QgbnVtYmVyIGZvciBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IHBhcnNlRmxvYXQoaXRlbS5zcGxpdCgnLScpWzBdKTtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHZlcnNpb24gbG93ZXIgdGhhbiB0aGUgY3VycmVudCB2ZXJzaW9uIHdlIGhhdmUgc3RvcmVkP1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmVyc2lvbiA9PT0gLTEgfHwgcmVzdWx0LnZlcnNpb24gPiBjb21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gY29tcGFyZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnByZWZpeGVkID0gKGhheXN0YWNrW2l0ZW1dLmluZGV4T2YoJ3gnKSA+IC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kU3VwcG9ydChicm93c2VyRGF0YSkge1xuICAgICAgICB2YXIgc3RhdHVzID0gWyd5JywgJ2EnLCAncCddLFxuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIGZpbmQgd2hhdCBzdXBwb3J0IGlzIGF2YWlsYWJsZSBmb3IgdGhpcyBicm93c2VyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdHVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmaW5kKHN0YXR1c1tpXSwgYnJvd3NlckRhdGEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ZXJzaW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICdyZXN1bHQnOiBzdGF0dXNbaV0sIC8vIHdoYXQgdHlwZSBvZiBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgICdwcmVmaXhlZCc6IHJlc3VsdC5wcmVmaXhlZCxcbiAgICAgICAgICAgICAgICAgICAgJ3ZlcnNpb24nOiAocmVzdWx0LnZlcnNpb24gIT09ICcwJykgPyByZXN1bHQudmVyc2lvbiA6ICcwJyAvLyB0aGUgdmVyc2lvbiB3aXRoIHRoYXQgc3VwcG9ydFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdyZXN1bHQnOiAnbicsXG4gICAgICAgICAgICAncHJlZml4ZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ05vJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qIHB1dCB0aGUgZGF0YSBpbiBhIG1vcmUgcGxhdGFibGUgZm9ybWF0ICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVSZXN1bHRzKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIGFnZW50cyA9IHt9LFxuICAgICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgICAgY3VycmVudEJyb3dzZXIgPSAnJyxcbiAgICAgICAgICAgIHN1cHBvcnQgPSB7fTtcblxuICAgICAgICBhZ2VudHMgPSBjYW5JVXNlRGF0YS5hZ2VudHMgfHwgY2FuSVVzZURhdGEucXVlcnkucmVzdWx0cy5qc29uLmFnZW50cztcblxuICAgICAgICByZXN1bHRzLnRpdGxlID0gZmVhdHVyZS50aXRsZTsgLy8gZmVhdHVyZSBuYW1lXG4gICAgICAgIHJlc3VsdHMuY29kZSA9IGZlYXR1cmU7IC8vIGZlYXR1cmUgY29kZT9cbiAgICAgICAgcmVzdWx0cy5zdGF0dXMgPSBnZXRTcGVjU3RhdHVzKGZlYXR1cmUuc3RhdHVzKTsgLy8gZmVhdHVyZSBzcGVjaWZpY2F0aW9uIHN0YXR1c1xuICAgICAgICByZXN1bHRzLmFnZW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gQlJPV1NFUlMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGN1cnJlbnRCcm93c2VyID0gQlJPV1NFUlNbaV07XG5cbiAgICAgICAgICAgIGlmIChhZ2VudHNbY3VycmVudEJyb3dzZXJdKSB7XG5cbiAgICAgICAgICAgICAgICBzdXBwb3J0ID0gZmluZFN1cHBvcnQoZmVhdHVyZS5zdGF0c1tCUk9XU0VSU1tpXV0pO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5hZ2VudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIFwiYnJvd3NlcmNvZGVcIjogY3VycmVudEJyb3dzZXIsXG4gICAgICAgICAgICAgICAgICAgIFwicHJlZml4ZWRcIjogc3VwcG9ydC5wcmVmaXhlZCxcbiAgICAgICAgICAgICAgICAgICAgXCJzdXBwb3J0Y29kZVwiOiBzdXBwb3J0LnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgXCJzdXBwb3J0XCI6IGdldFN1cHBvcnRTdGF0dXMoc3VwcG9ydC5yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IGFnZW50c1tjdXJyZW50QnJvd3Nlcl0uYnJvd3NlcixcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IGFnZW50c1tjdXJyZW50QnJvd3Nlcl0udHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBcInZlcnNpb25cIjogc3VwcG9ydC52ZXJzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSHRtbChyZXN1bHRzKSB7XG5cbiAgICAgICAgdmFyIGh0bWwgPSAnJyxcbiAgICAgICAgICAgIHJlc3VsdEh0bWwgPSAnJyxcbiAgICAgICAgICAgIGRlc2t0b3BIdG1sID0gJycsXG4gICAgICAgICAgICBtb2JpbGVIdG1sID0gJycsXG4gICAgICAgICAgICBwcmVmaXhlcyA9IGZhbHNlLFxuICAgICAgICAgICAgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSAwO1xuXG4gICAgICAgIHJlc3VsdEh0bWwgPSBUTVBMX1RJVExFLnJlcGxhY2UoJ3t0aXRsZX0nLCByZXN1bHRzLnRpdGxlKTtcbiAgICAgICAgcmVzdWx0SHRtbCArPSBUTVBMX1NUQVRVUy5yZXBsYWNlKCd7c3RhdHVzfScsIHJlc3VsdHMuc3RhdHVzKTtcbiAgICAgICAgcmVzdWx0SHRtbCArPSBUTVBMX0RFU0NSSVBUSU9OO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSByZXN1bHRzLmFnZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMuYWdlbnRzW2ldOyAvLyBzaW1wbHkgdGhpbmdzXG5cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2hvdyB0aGF0IHByZWZpeCBub3RpY2UsIGNhcHRhaW5cbiAgICAgICAgICAgIGlmIChyZXN1bHQucHJlZml4ZWQpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXhlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgPSBUTVBMX1NVUFBPUlQucmVwbGFjZSgvXFx7YnJvd3NlcmNvZGVcXH0vZywgcmVzdWx0LmJyb3dzZXJjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce3ByZWZpeGVkXFx9L2csIChyZXN1bHQucHJlZml4ZWQgPT09IHRydWUpID8gJyonIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7c3VwcG9ydGNvZGVcXH0vZywgcmVzdWx0LnN1cHBvcnRjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce3N1cHBvcnRcXH0vZywgcmVzdWx0LnN1cHBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7YnJvd3NlclxcfS9nLCByZXN1bHQudGl0bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx7dmVyc2lvblxcfS9nLCByZXN1bHQudmVyc2lvbik7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Rlc2t0b3AnKSB7XG4gICAgICAgICAgICAgICAgZGVza3RvcEh0bWwgKz0gaHRtbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnR5cGUgPT09ICdtb2JpbGUnKSB7XG4gICAgICAgICAgICAgICAgbW9iaWxlSHRtbCArPSBodG1sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBzaG93IGlmIHdlIGFyZSBpbmNsdWRpbmcgZGVza3RvcCBicm93c2Vyc1xuICAgICAgICBpZiAoZGVza3RvcEh0bWwgIT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHRIdG1sICs9IFRNUExfREVTS1RPUF9USVRMRTtcbiAgICAgICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9TVVBQT1JUX1dSQVBQRVIucmVwbGFjZSgvXFx7aXRlbXNcXH0vZywgZGVza3RvcEh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBzaG93IGlmIHdlIGFyZSBpbmNsdWRpbmcgbW9iaWxlIGJyb3dzZXJzXG4gICAgICAgIGlmIChtb2JpbGVIdG1sICE9PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0SHRtbCArPSBUTVBMX01PQklMRV9USVRMRTtcbiAgICAgICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9TVVBQT1JUX1dSQVBQRVIucmVwbGFjZSgvXFx7aXRlbXNcXH0vZywgbW9iaWxlSHRtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlZml4ZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9QUkVGSVhfTk9URTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9MRUdFTkQ7XG4gICAgICAgIHJlc3VsdEh0bWwgKz0gVE1QTF9GT09URVIucmVwbGFjZSgvXFx7ZmVhdHVyZVxcfS9nLCByZXN1bHRzLmZlYXR1cmVDb2RlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdEh0bWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUoZWxlbWVudElkKSB7XG4gICAgICAgIHZhciAkY2FuSVVzZSA9IFtdLFxuICAgICAgICAgICAgJGluc3RhbmNlLFxuICAgICAgICAgICAgZmVhdHVyZUNvZGUgPSAnJyxcbiAgICAgICAgICAgIGZlYXR1cmUgPSB7fSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsID0gMDtcblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRJZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgJGNhbklVc2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FuaXVzZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGNhbklVc2UucHVzaChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGwgPSAkY2FuSVVzZS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgJGluc3RhbmNlID0gJGNhbklVc2VbaV07XG4gICAgICAgICAgICBmZWF0dXJlQ29kZSA9ICRpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmVhdHVyZScpIHx8ICd1bmtub3duJztcbiAgICAgICAgICAgIGZlYXR1cmUgPSBnZXRGZWF0dXJlKGZlYXR1cmVDb2RlKTtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHRzKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5mZWF0dXJlQ29kZSA9IGZlYXR1cmVDb2RlO1xuICAgICAgICAgICAgICAgICRpbnN0YW5jZS5pbm5lckhUTUwgPSBnZW5lcmF0ZUh0bWwocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGluc3RhbmNlLmlubmVySFRNTCA9IFRNUExfRVJST1IucmVwbGFjZSgvXFx7ZmVhdHVyZVxcfS9nLCBmZWF0dXJlQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93TG9hZGluZyhlbGVtZW50SWQpIHtcbiAgICAgICAgdmFyICRjYW5JVXNlID0gW10sXG4gICAgICAgICAgICAkaW5zdGFuY2UsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudElkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAkY2FuSVVzZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYW5pdXNlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkY2FuSVVzZS5wdXNoKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbCA9ICRjYW5JVXNlLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAkaW5zdGFuY2UgPSAkY2FuSVVzZVtpXTtcbiAgICAgICAgICAgICRpbnN0YW5jZS5pbm5lckhUTUwgPSBUTVBMX0xPQURJTkc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIExvYWQgdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkRGF0YShlbGVtZW50SWQsIHBvcHVsYXRlKSB7XG4gICAgICAgIHZhciB1cmwgPSAnJyxcbiAgICAgICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1NDUklQVCcpO1xuXG4gICAgICAgIHVybCA9ICdodHRwOi8vcXVlcnkueWFob29hcGlzLmNvbS92MS9wdWJsaWMveXFsP3E9JyArXG4gICAgICAgICAgICAnc2VsZWN0ICogZnJvbSBqc29uIHdoZXJlIHVybCA9IFxcJycgKyBTT1VSQ0VfREFUQV9VUkwgKyAnXFwnJyArXG4gICAgICAgICAgICAnJmZvcm1hdD1qc29uJmpzb25Db21wYXQ9bmV3JmNhbGxiYWNrPWNhbklVc2VEYXRhTG9hZGVkJztcblxuICAgICAgICAvLyByZW1lbWJlciB0aGVzZSBmb3Igd2hlbiBvdXIgSlNPTlAgcmV0dXJuc1xuICAgICAgICBzdG9yZUVsZW1lbnRJZCA9IGVsZW1lbnRJZDtcbiAgICAgICAgcG9wdWxhdGVPbkxvYWQgPSBwb3B1bGF0ZTtcblxuICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wdWxhdGUoZWxlbWVudElkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FuSVVzZURhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzaG93TG9hZGluZyhlbGVtZW50SWQpO1xuICAgICAgICAgICAgbG9hZERhdGEoZWxlbWVudElkLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlbmVyYXRlKGVsZW1lbnRJZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFB1YmxpYyBNZXRob2RzXG4gICAgICovXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyOiBwb3B1bGF0ZSxcbiAgICAgICAgZGF0YUxvYWRlZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGNhbklVc2VEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGlmIChwb3B1bGF0ZU9uTG9hZCkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlKHN0b3JlRWxlbWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdDogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChBVVRPX1JVTikge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEJFX1JFQURZKSB7XG4gICAgICAgICAgICAgICAgbG9hZERhdGEodW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9O1xufSgpKTtcblxud2luZG93LmNhbklVc2VEYXRhTG9hZGVkID0gZnVuY3Rpb24gY2FuSVVzZURhdGFMb2FkZWQoZGF0YSkge1xuICAgIGNhbklVc2UuZGF0YUxvYWRlZChkYXRhKTtcbn07XG4iXX0="}